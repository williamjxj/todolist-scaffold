# Data Model

**Feature**: TODO List Application  
**Date**: 2025-01-27  
**Status**: Complete

## Entity: TodoItem

Represents a single TODO item in the system.

### Attributes

| Attribute | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `id` | Integer (Primary Key) | Auto-increment, Unique, Not Null | Unique identifier for the TODO item |
| `description` | String (Text) | Max 500 characters, Not Null, Not Empty | The text content describing the task. Supports Unicode, emojis, and multi-line text |
| `completed` | Boolean | Default: False, Not Null | Whether the item is completed (true) or pending (false) |
| `created_at` | DateTime | Auto-set on creation, Not Null | Timestamp when the item was created |
| `updated_at` | DateTime | Auto-update on modification, Not Null | Timestamp when the item was last modified |

### Validation Rules

1. **Description Validation**:
   - Must not be empty or whitespace-only (trimmed)
   - Maximum length: 500 characters
   - Supports Unicode characters, emojis, and multi-line text
   - Validation occurs on both frontend (immediate feedback) and backend (security boundary)

2. **ID Validation**:
   - Auto-generated by database
   - Must be unique
   - Immutable after creation

3. **Completion Status**:
   - Boolean value (true/false)
   - Defaults to `false` (pending) on creation
   - Can be toggled between completed and pending

4. **Timestamps**:
   - `created_at`: Set automatically on creation, never changes
   - `updated_at`: Set automatically on creation and updated on any modification

### State Transitions

```
[New] → created_at set, completed = false
  ↓
[Pending] → completed = false
  ↓
[Completed] → completed = true
  ↓
[Pending] → completed = false (can toggle back)
```

**Note**: There is no "deleted" state. Deletion removes the record entirely from the database.

### Database Schema

**Table Name**: `todos`

**SQLAlchemy Model**:
```python
class TodoItem(Base):
    __tablename__ = "todos"
    
    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    description: Mapped[str] = mapped_column(Text, nullable=False)
    completed: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
```

**SQLite Schema** (for reference):
```sql
CREATE TABLE todos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    description TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_todos_completed ON todos(completed);
```

### Relationships

**None**: This is a simple, single-entity model with no relationships to other entities.

### Indexes

1. **Primary Key Index**: `id` (automatic)
2. **Completion Status Index**: `completed` (for filtering completed vs pending items)

**Rationale**: 
- Primary key index enables fast lookups by ID
- Completion status index enables efficient filtering when displaying completed vs pending items
- For 1000 items, these indexes are sufficient

### Data Constraints

1. **Uniqueness**: `id` must be unique
2. **Non-nullability**: All fields are required (NOT NULL)
3. **Length**: `description` maximum 500 characters
4. **Content**: `description` must not be empty or whitespace-only after trimming

### Pydantic Schemas (API Layer)

#### TodoItemCreate (Request)
```python
class TodoItemCreate(BaseModel):
    description: str = Field(..., min_length=1, max_length=500, description="TODO item description")
```

#### TodoItemUpdate (Request)
```python
class TodoItemUpdate(BaseModel):
    description: Optional[str] = Field(None, min_length=1, max_length=500)
    completed: Optional[bool] = None
```

#### TodoItemResponse (Response)
```python
class TodoItemResponse(BaseModel):
    id: int
    description: str
    completed: bool
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True  # For SQLAlchemy model conversion
```

### TypeScript Types (Frontend)

```typescript
interface TodoItem {
  id: number;
  description: string;
  completed: boolean;
  created_at: string;  // ISO 8601 datetime string
  updated_at: string;  // ISO 8601 datetime string
}

interface TodoItemCreate {
  description: string;
}

interface TodoItemUpdate {
  description?: string;
  completed?: boolean;
}
```

### Data Flow

1. **Create**: Frontend sends `TodoItemCreate` → Backend validates → Creates `TodoItem` → Returns `TodoItemResponse`
2. **Read**: Frontend requests by ID or list → Backend queries database → Returns `TodoItemResponse`(s)
3. **Update**: Frontend sends `TodoItemUpdate` → Backend validates → Updates `TodoItem` → Returns `TodoItemResponse`
4. **Delete**: Frontend requests deletion → Backend deletes record → Returns success/error

### Error Scenarios

1. **Empty/Whitespace Description**: 
   - Frontend: Prevents submission, shows inline validation
   - Backend: Returns 422 validation error

2. **Description Too Long**:
   - Frontend: Prevents submission, shows inline validation
   - Backend: Returns 422 validation error

3. **Non-existent ID**:
   - Backend: Returns 404 Not Found
   - Frontend: Shows error message and refreshes list

4. **Concurrent Edits**:
   - Backend: Last write wins (no locking)
   - Frontend: May show stale data until refresh

### Data Migration Strategy

**Initial Schema**: Create table with all fields from start (no migration needed for demo)

**Future Considerations** (if needed):
- Use Alembic for schema versioning
- Migration scripts for schema changes
- For demo, can recreate database if schema changes

### Data Integrity

1. **Referential Integrity**: N/A (no foreign keys)
2. **Check Constraints**: Description length enforced by application and database
3. **Transaction Safety**: SQLAlchemy handles transactions automatically
4. **Concurrency**: Last-write-wins approach (no explicit locking)

### Performance Considerations

1. **Query Optimization**: 
   - Index on `completed` for filtering
   - Primary key index for lookups
   - Simple queries (no joins) = fast execution

2. **Data Volume**:
   - Designed for up to 1000 items
   - SQLite handles this efficiently
   - No pagination needed at this scale

3. **Caching**:
   - Not required for demo
   - Can add React Query/SWR later if needed

## Summary

The data model is intentionally simple:
- Single entity (TodoItem)
- No relationships
- Minimal fields (id, description, completed, timestamps)
- Clear validation rules
- Type-safe at both backend and frontend layers
- Optimized for the demo's scale (1000 items)

This simplicity makes it easy to understand for entry-level developers while demonstrating best practices (type safety, validation, indexing).
